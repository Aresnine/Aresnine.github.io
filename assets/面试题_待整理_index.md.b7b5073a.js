import{_ as e,o as l,c as i,e as t}from"./app.db42a1fc.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"1、生命周期","slug":"_1、生命周期","link":"#_1、生命周期","children":[]},{"level":3,"title":"2、父子生命周期","slug":"_2、父子生命周期","link":"#_2、父子生命周期","children":[]},{"level":3,"title":"3、组件间的通信","slug":"_3、组件间的通信","link":"#_3、组件间的通信","children":[]},{"level":3,"title":"4、slot","slug":"_4、slot","link":"#_4、slot","children":[]},{"level":3,"title":"5、响应式原理","slug":"_5、响应式原理","link":"#_5、响应式原理","children":[]},{"level":3,"title":"6、diff算法","slug":"_6、diff算法","link":"#_6、diff算法","children":[]},{"level":3,"title":"7、patch","slug":"_7、patch","link":"#_7、patch","children":[]}],"relativePath":"面试题/待整理/index.md"}'),a={name:"面试题/待整理/index.md"},r=t('<p>待整理面试题</p><p>1、箭头函数和普通函数的区别</p><ol><li>箭头函数比普通函数更简洁</li><li>箭头函数没有自己的this</li><li>箭头函数的this指向永远不会改变</li><li>call、apply、bind不能改变箭头函数中的this指向</li><li>不能作为构造函数</li><li>没有arguments</li><li>没有自己prototype</li><li>箭头函数不能作为Generator函数，不能使用yeild关键字</li></ol><p>2、let、const、var</p><ol><li>var可以重复声明变量 let、const不能</li><li>var存在变量声明的提升，在变量声明之前使用不会报错，let和const存在暂时性死区，不能再变量声明之前使用变量</li><li>let和const支持块级作用域</li><li>const必须设置初始值</li><li>let和var都可以二次赋值，const称之为常量</li></ol><p>4、object.assgn和<code>...</code>都可以进行对象的浅拷贝</p><p>5、如何实现对象的深拷贝？</p><p>6、数组的扩展运算符有什么用？</p><p>7、new操作符</p><ol><li>创建一个新的空对象</li><li>设置原型，将这个对象的原型设置为函数的prototype对象</li><li>让函数的this指向这个对象，执行构造函数的代码（为这个对象添加属性）</li><li>返回this所指向的对象</li></ol><p>8、map</p><p>map本质就是键值对的集合，但是普通的对象Object中的键只能是字符串，而ES6提供的map数据结构更类似与对象，但是键不限制范围，可以是任意的类型，是一种更完善的hash结构</p><blockquote><p>方法:</p></blockquote><ul><li>size:返回成员总数</li><li>set：设置值（添加和修改）</li><li>get：获得</li><li>has：是否存在</li><li>delete：删除</li><li>clear：全部清除</li></ul><blockquote><p>遍历：</p></blockquote><ul><li>keys</li><li>values</li><li>entries</li><li>forEach</li></ul><p>weakmap设计的目的在于，有时想在对象上面存放一些数据，但是这会形成对于这个对象的引用，一旦不再需要这两个对象，就必须手动删除，否则垃圾回收机制就不会释放是对象的内存。而weakmap的键名 所引用的对象都市弱引用。</p><p>9、js脚本延迟加载方式有哪些?</p><ol><li>defer</li><li>async</li><li>冬天创建dom</li><li>使用setTimeout</li><li>让js最后加载</li></ol><p>10、类数组对象转为数组的方法</p><ol><li>Array.prototype.slice.call(arrayLike)</li><li>Array.prototype.splice.call(arrayLike)</li><li>Array.prototype.concat.apply([], arrayLike)</li><li>Array.from(arrayLike)</li></ol><p>11、es6模块与COmmonjs模块有什么异同？</p><ol><li>Commonjs是对模块的浅拷贝，ES6 Module是对模块的引用，即ES6 Module只存只读，不能改变其值，也就是指针指向不能改变，类似const</li><li>import的接口是read-only只读状态，不能修改器变量值，即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonjs重新赋值（改变指针指向），但是对ES6 Module赋值会编译错误</li></ol><p>nextick实现方式</p><p>缓存</p><p>浏览器渲染流程</p><p>算法： 复杂度</p><h3 id="_1、生命周期" tabindex="-1">1、生命周期 <a class="header-anchor" href="#_1、生命周期" aria-hidden="true">#</a></h3><p>beforeCreated=》created=》beforeMount=》mounted=》beforeUpdate =》updated =》 beforeDestroy =》 Destroy</p><p>keep-alive下： activated 和 deactivated</p><p>errorCaptured</p><h3 id="_2、父子生命周期" tabindex="-1">2、父子生命周期 <a class="header-anchor" href="#_2、父子生命周期" aria-hidden="true">#</a></h3><p>父beforeCreated =》 父created =&gt; 父beforeMounted =》 子 beforeCreated =》 子created =》 子beforeMounted =》 子mounted =》 父mounted</p><p>子组件先挂载，然后父组件</p><p>更新： 父 beforeUpdate =》 子beforeUpdate =》 子updated =》 父updated</p><p>销毁：父 beforeDestroy =》 子beforeDestroy=》 子Destroy =》 父Destroy</p><p>在父组件传递接口数据给子组件的时候，一定要在子组件的标签上加上v-if=&quot;接口数据&quot;</p><h3 id="_3、组件间的通信" tabindex="-1">3、组件间的通信 <a class="header-anchor" href="#_3、组件间的通信" aria-hidden="true">#</a></h3><blockquote><p>props, $on, $emit, $parent, $children, ref，$refs, $attrs, $listeners</p></blockquote><ul><li>父组件向子组件传值 <ul><li>通过props</li></ul></li><li>子组件向父组件传值</li></ul><h3 id="_4、slot" tabindex="-1">4、slot <a class="header-anchor" href="#_4、slot" aria-hidden="true">#</a></h3><h3 id="_5、响应式原理" tabindex="-1">5、响应式原理 <a class="header-anchor" href="#_5、响应式原理" aria-hidden="true">#</a></h3><h3 id="_6、diff算法" tabindex="-1">6、diff算法 <a class="header-anchor" href="#_6、diff算法" aria-hidden="true">#</a></h3><ul><li>同级比较</li><li>标签名不同，直接删除，不进行深层次的比较</li><li>标签名相同，比较key，key相同就认为是相同节点，不继续深度比较</li></ul><p>6、虚拟DOM(vitual DOM)</p><p>vnode ={</p><p>​ tag: &#39;标签名div&#39;，</p><p>​ props: {</p><p>​ id: &#39;main&#39;</p><p>​ } ,</p><p>​ children: {</p><p>​</p><p>​ }</p><p>}</p><p>7、diff算法（patch）</p><h3 id="_7、patch" tabindex="-1">7、patch <a class="header-anchor" href="#_7、patch" aria-hidden="true">#</a></h3>',56),p=[r];function o(d,s,n,c,h,_){return l(),i("div",null,p)}const m=e(a,[["render",o]]);export{f as __pageData,m as default};
